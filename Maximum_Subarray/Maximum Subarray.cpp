/*
首先根據題目可以直覺想到暴力法
即算出所有答案
首先可以拆出四個步驟
1.選擇一個起點
2.選擇一個終點
3.計算起點到終點的和
4.如果此和比原本的最大值大，就換掉

比較注意的只有一個問題
即儲存最大值的變數max的初始值該設什麼? 假如設定0會導致如果最大值為負數時產生錯誤
解決:
1.使用陣列的第一個值當作初始值
2.觀察題目可知是給int，故使用標準巨集 INT_MIN 將max初始值設定為INT的最小值即可


------但會產生TLE(Time limit)-------------------\

加速時有幾種作法
以1 + 2 + 3 + .... + 1000 為例
數學公式 :
((1   + 2   +3   +....+1000) +
(1000 + 999 +998 +....+1))  / 2 => (1+1000)*1000/2
首先以自己加自己/2 來得出
可以發現會是1000個1001加起來/2，故有了最終的等價公式
這告訴了我們，發現"重複運算"的重要性，可以進行優化


因此可以知道我們要將重複運算的for迴圈，進行修剪會最好。

想辦法將3層迴圈縮減成2層迴圈: 在第3點可改成用上一輪的sum + 這次的nums值




*/

class Solution {
public:
    int maxSubArray(vector<int>& nums) {

        int max = INT_MIN; // 目前為止的最大值

        //1.選擇一個起點
        for (int i = 0; i < nums.size(); i++)
        {
            int sum = 0;

            //2.選擇一個終點
            for (int j = i; j < nums.size(); j++)
            {

                /*
                //3.計算起點到終點的和
                int sum = 0;
                for(int k = i; k<= j; k++)
                {
                    sum += nums[k];
                }
                */

                //第3點的更改
                sum += nums[j];


                //4.如果比原本的最大值大，就換掉
                if (sum > max) {
                    max = sum;
                }
            }
        }
        return max;
    }
};